char *str;

b=(int)ptr; //把指针ptr 的值当作一个整数取出来。

str=(char*)b;
//把这个整数的值当作一个地址赋给指针str。

现在我们已经知道了，可以把指针的值当作一个整数取
出来，也可

以把一个整数值当作地址赋给一个指针。

9、指针的安全问题

看下面的例子：

例十八：

char s='a';

int *ptr;

ptr=(int *)&s;

*ptr=1298；

指针ptr 是一个int
*类型的指针，它指向的类型是int。它指向

的地址就是s 的首地址。在32 位程序中，s
占一个字节，int
类型占四个字节。最后一条语句不但改变了s
所占的一个字节，还把和s
相临的高地址方向的三个字节也改变了。这三个字节是
干什么的？只有编译程序知道，而写程序的人是不太可
能知道的。也许这三个字节里存储了非常重要的数据，
也许这三个字节里正好是程序的一条代码，而由于你对
指针的马虎应用，这三个字节的值被改变了！这会造成
崩溃性的错误。

让我们再来看一例：

例十九：

char a;

int *ptr=&a;

ptr++;

*ptr=115;

该例子完全可以通过编译，并能执行。但是看到没有？
第3 句对指

`

b

t

v

~

Ђ

Ћ

ђ

Ё

Є

¶

ё

К

М

0

И

b

v

Ђ

ђ

Є

ё

М

␃愀$᠀sizeof(ptr2的类型)大于sizeof(ptr1
的类型)，那么在使用指针ptr1
来访问ptr2所指向的存储区时是安全的。如果sizeof(ptr2
的类型) 小于sizeof(ptr1 的类型)，那么在使用指针ptr1
来访问ptr2
所指向的存储区时是不安全的。至于为什么，读者结合
例十八来想一想，应该会明白的。

10、结束语

现在你是否已经觉得指针再也不是你所想的那么害怕了
，如果你的回答是：对，我不怕了！哈哈，恭喜你，你
已经掌握C
语言的精华了，C中唯一的难点就是指针，指针搞定其
小菜而已，重要的是实践，好吧，让我们先暂停C
的旅程吧，开始我们的C++编程，C
是对底层操作非常方便的语言，但开发大型程序本人觉
得还是没有C++方便，至少维护方面不太好做。而且C++是
面向对象的语言，现在基本已经是面向对象的天下了，
所以建议学C++。C++是一门难学易用的语言，要真正掌握
C++可不是那么容易的，将基本的学完后，就学数据结构
吧，算法才是永恒的，程序设计语言层出不穷，永远学
不完。学完之后就认真啃下STL
这根骨头吧，推荐籍--------范型编程与STL 和STL
源码剖析。如果你达到了这样要求，再一次恭喜你，你
已经是个程序高手了，甚至可以说是个算法高手，因为
STL
里有大量的精华而高效的算法。唉，已经该说再见的时
候了，让我们一起用我们的语言来谱写我们的人生吧，
最后笑个，哈哈，睡觉了。好累，都2：00 了__

